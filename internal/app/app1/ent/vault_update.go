// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/pepeunlimited/checkout/internal/app/app1/ent/predicate"
	"github.com/pepeunlimited/checkout/internal/app/app1/ent/vault"
)

// VaultUpdate is the builder for updating Vault entities.
type VaultUpdate struct {
	config
	amount           *int64
	addamount        *int64
	reference_number *string
	predicates       []predicate.Vault
}

// Where adds a new predicate for the builder.
func (vu *VaultUpdate) Where(ps ...predicate.Vault) *VaultUpdate {
	vu.predicates = append(vu.predicates, ps...)
	return vu
}

// SetAmount sets the amount field.
func (vu *VaultUpdate) SetAmount(i int64) *VaultUpdate {
	vu.amount = &i
	vu.addamount = nil
	return vu
}

// AddAmount adds i to amount.
func (vu *VaultUpdate) AddAmount(i int64) *VaultUpdate {
	if vu.addamount == nil {
		vu.addamount = &i
	} else {
		*vu.addamount += i
	}
	return vu
}

// SetReferenceNumber sets the reference_number field.
func (vu *VaultUpdate) SetReferenceNumber(s string) *VaultUpdate {
	vu.reference_number = &s
	return vu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (vu *VaultUpdate) Save(ctx context.Context) (int, error) {
	if vu.reference_number != nil {
		if err := vault.ReferenceNumberValidator(*vu.reference_number); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"reference_number\": %v", err)
		}
	}
	return vu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (vu *VaultUpdate) SaveX(ctx context.Context) int {
	affected, err := vu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (vu *VaultUpdate) Exec(ctx context.Context) error {
	_, err := vu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (vu *VaultUpdate) ExecX(ctx context.Context) {
	if err := vu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (vu *VaultUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   vault.Table,
			Columns: vault.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: vault.FieldID,
			},
		},
	}
	if ps := vu.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := vu.amount; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: vault.FieldAmount,
		})
	}
	if value := vu.addamount; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: vault.FieldAmount,
		})
	}
	if value := vu.reference_number; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: vault.FieldReferenceNumber,
		})
	}
	if n, err = sqlgraph.UpdateNodes(ctx, vu.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// VaultUpdateOne is the builder for updating a single Vault entity.
type VaultUpdateOne struct {
	config
	id               int
	amount           *int64
	addamount        *int64
	reference_number *string
}

// SetAmount sets the amount field.
func (vuo *VaultUpdateOne) SetAmount(i int64) *VaultUpdateOne {
	vuo.amount = &i
	vuo.addamount = nil
	return vuo
}

// AddAmount adds i to amount.
func (vuo *VaultUpdateOne) AddAmount(i int64) *VaultUpdateOne {
	if vuo.addamount == nil {
		vuo.addamount = &i
	} else {
		*vuo.addamount += i
	}
	return vuo
}

// SetReferenceNumber sets the reference_number field.
func (vuo *VaultUpdateOne) SetReferenceNumber(s string) *VaultUpdateOne {
	vuo.reference_number = &s
	return vuo
}

// Save executes the query and returns the updated entity.
func (vuo *VaultUpdateOne) Save(ctx context.Context) (*Vault, error) {
	if vuo.reference_number != nil {
		if err := vault.ReferenceNumberValidator(*vuo.reference_number); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"reference_number\": %v", err)
		}
	}
	return vuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (vuo *VaultUpdateOne) SaveX(ctx context.Context) *Vault {
	v, err := vuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query on the entity.
func (vuo *VaultUpdateOne) Exec(ctx context.Context) error {
	_, err := vuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (vuo *VaultUpdateOne) ExecX(ctx context.Context) {
	if err := vuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (vuo *VaultUpdateOne) sqlSave(ctx context.Context) (v *Vault, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   vault.Table,
			Columns: vault.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  vuo.id,
				Type:   field.TypeInt,
				Column: vault.FieldID,
			},
		},
	}
	if value := vuo.amount; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: vault.FieldAmount,
		})
	}
	if value := vuo.addamount; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt64,
			Value:  *value,
			Column: vault.FieldAmount,
		})
	}
	if value := vuo.reference_number; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: vault.FieldReferenceNumber,
		})
	}
	v = &Vault{config: vuo.config}
	_spec.Assign = v.assignValues
	_spec.ScanValues = v.scanValues()
	if err = sqlgraph.UpdateNode(ctx, vuo.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return v, nil
}
